{
  "tasks": [
    {
      "id": 1,
      "title": "Setup React Native Project with TypeScript",
      "description": "Initialize the React Native CLI project with TypeScript for the HomEE mobile application, configure essential dependencies, and establish the project structure.",
      "details": "1. Initialize a new React Native project using CLI with TypeScript template:\n```bash\nnpx react-native init HomEEApp --template react-native-template-typescript\n```\n2. Configure essential dependencies:\n- Navigation: @react-navigation/native, @react-navigation/bottom-tabs, @react-navigation/stack\n- State management: Redux Toolkit or Context API\n- Form handling: react-hook-form\n- Network requests: axios\n- UI components: react-native-elements or similar\n3. Setup project structure:\n```\n/src\n  /api - API service layer\n  /assets - Images, icons, etc.\n  /components - Reusable UI components\n  /constants - App constants\n  /hooks - Custom hooks\n  /navigation - Navigation configuration\n  /screens - App screens\n  /services - Business logic services\n  /store - State management\n  /types - TypeScript type definitions\n  /utils - Utility functions\n```\n4. Configure ESLint and Prettier for code quality\n5. Setup basic CI configuration for the project",
      "testStrategy": "1. Verify project builds successfully for both iOS and Android\n2. Run basic smoke tests to ensure the app launches without errors\n3. Validate TypeScript configuration works correctly\n4. Ensure all dependencies are correctly installed and imported\n5. Verify ESLint and Prettier configurations work as expected",
      "priority": "high",
      "dependencies": [],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 2,
      "title": "Implement Realm Database Integration",
      "description": "Set up and configure Realm Database for local data storage and offline capabilities, including schema definitions for all required data models.",
      "details": "1. Install Realm dependencies:\n```bash\nnpm install realm @realm/react\n```\n2. Define Realm schemas for all data models mentioned in the PRD:\n```typescript\n// Example schema for User model\nclass User extends Realm.Object {\n  static schema = {\n    name: 'User',\n    primaryKey: 'id',\n    properties: {\n      id: 'string',\n      username: 'string',\n      firstName: 'string',\n      lastName: 'string',\n      email: 'string?',\n      phone: 'string?',\n      gender: 'string?',\n      role: 'string',\n      tenantId: 'string?',\n      settings: 'UserSettings?',\n      lastSyncTimestamp: 'date'\n    }\n  };\n}\n```\n3. Create similar schemas for: Job/Task, InspectionPoint, Article, ShoppingList, Location, Unit/SubUnit, Template, Warehouse, CostLine, FollowUpAction\n4. Implement RealmContext provider for React components\n5. Create database service with CRUD operations for each model\n6. Implement database initialization and migration strategies\n7. Setup encryption for sensitive data",
      "testStrategy": "1. Unit test each schema definition for correctness\n2. Test CRUD operations for each model\n3. Verify relationships between models work correctly\n4. Test database initialization and migration\n5. Benchmark performance with large datasets\n6. Verify encryption works correctly for sensitive data\n7. Test database operations in offline mode",
      "priority": "high",
      "dependencies": [
        1
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 3,
      "title": "Create Authentication Workflow UI",
      "description": "Implement the authentication screens and workflow, including username input, tenant selection for multi-tenant users, password input, and password reset functionality.",
      "details": "1. Create the following authentication screens with consistent two-section layout:\n   - Username Input Screen\n   - Tenant Selection Screen (for multi-tenant users)\n   - Password Input Screen\n   - Password Reset Screen\n\n2. Implement form validation:\n   - Username validation\n   - Password validation with complexity rules (for reset)\n   - Required field validation\n\n3. Create UI components:\n```typescript\n// Example component structure\nconst UsernameScreen = () => {\n  const [username, setUsername] = useState('');\n  const [error, setError] = useState('');\n  \n  const handleContinue = () => {\n    if (!username.trim()) {\n      setError('Username is required');\n      return;\n    }\n    // Navigate to next screen (tenant selection or password)\n  };\n  \n  return (\n    <AuthLayout title=\"Login\">\n      <TextInput\n        value={username}\n        onChangeText={setUsername}\n        placeholder=\"Username\"\n        autoCapitalize=\"none\"\n      />\n      {error ? <Text style={styles.error}>{error}</Text> : null}\n      <Button title=\"Continue\" onPress={handleContinue} />\n    </AuthLayout>\n  );\n};\n```\n\n4. Implement navigation flow between authentication screens\n5. Create password reset flow with 6-month expiration check\n6. Design and implement password complexity validation for reset screen",
      "testStrategy": "1. Unit test each authentication screen component\n2. Test form validation logic for all inputs\n3. Verify navigation flow between screens works correctly\n4. Test multi-tenant vs. single-tenant flow differences\n5. Verify password reset flow and complexity validation\n6. Test error handling and display\n7. Perform usability testing with different input scenarios\n8. Verify UI matches the specified two-section layout",
      "priority": "high",
      "dependencies": [
        1
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 4,
      "title": "Implement Authentication Service",
      "description": "Create the authentication service to handle user login, tenant selection, password validation, and integration with the external authentication system.",
      "details": "1. Create an authentication service with the following methods:\n```typescript\nclass AuthService {\n  // Check if username exists and determine if single or multi-tenant\n  async validateUsername(username: string): Promise<{valid: boolean, multiTenant: boolean}> {...}\n  \n  // Get available tenants for a user\n  async getTenants(username: string): Promise<Tenant[]> {...}\n  \n  // Authenticate user with username, password, and optional tenantId\n  async login(username: string, password: string, tenantId?: string): Promise<User> {...}\n  \n  // Check if password reset is required (not changed in 6 months)\n  async checkPasswordResetRequired(userId: string): Promise<boolean> {...}\n  \n  // Reset password with validation\n  async resetPassword(userId: string, currentPassword: string, newPassword: string): Promise<boolean> {...}\n  \n  // Store authentication tokens securely\n  private storeTokens(tokens: AuthTokens): Promise<void> {...}\n  \n  // Get stored tokens\n  async getTokens(): Promise<AuthTokens | null> {...}\n  \n  // Clear stored tokens on logout\n  async logout(): Promise<void> {...}\n}\n```\n\n2. Implement secure storage for authentication tokens using react-native-keychain\n3. Create API client for external authentication system integration\n4. Implement password complexity validation logic\n5. Create authentication context provider for React components\n6. Implement automatic token refresh mechanism\n7. Handle authentication errors and provide meaningful messages",
      "testStrategy": "1. Unit test all authentication service methods\n2. Mock external authentication API for testing\n3. Test token storage and retrieval\n4. Verify password complexity validation logic\n5. Test multi-tenant vs. single-tenant authentication flows\n6. Test password reset flow and validation\n7. Verify error handling for various authentication failure scenarios\n8. Test token refresh mechanism\n9. Verify secure storage of credentials",
      "priority": "high",
      "dependencies": [
        2,
        3
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 5,
      "title": "Create Global Application Layout",
      "description": "Implement the consistent main layout structure for all post-login screens, including the standard header with network status, notification, and profile icons, and the bottom navigation bar.",
      "details": "1. Create a reusable AppLayout component:\n```typescript\nconst AppLayout: React.FC<{\n  title: string;\n  children: React.ReactNode;\n}> = ({ title, children }) => {\n  const isOnline = useNetworkStatus();\n  const notifications = useNotifications();\n  \n  return (\n    <SafeAreaView style={styles.container}>\n      <Header \n        title={title}\n        networkStatus={isOnline ? 'online' : 'offline'}\n        notificationCount={notifications.length}\n      />\n      <View style={styles.content}>{children}</View>\n      <BottomNavigation />\n    </SafeAreaView>\n  );\n};\n```\n\n2. Implement Header component with:\n   - Screen title display\n   - Network status icon (green for online, red for offline)\n   - Notification icon with optional badge\n   - Profile icon for accessing user settings\n\n3. Implement BottomNavigation component with icons for:\n   - \"This Week\" (Home)\n   - \"Shopping List\"\n   - \"Task\" (Job List)\n\n4. Create navigation configuration using React Navigation:\n```typescript\nconst BottomTab = createBottomTabNavigator();\n\nconst MainNavigator = () => (\n  <BottomTab.Navigator>\n    <BottomTab.Screen name=\"Home\" component={HomeScreen} />\n    <BottomTab.Screen name=\"ShoppingList\" component={ShoppingListScreen} />\n    <BottomTab.Screen name=\"Tasks\" component={TasksScreen} />\n  </BottomTab.Navigator>\n);\n```\n\n5. Implement network status detection hook\n6. Create custom tab bar icons and styling\n7. Ensure consistent styling across different device sizes",
      "testStrategy": "1. Unit test AppLayout, Header, and BottomNavigation components\n2. Test network status detection and icon color changes\n3. Verify navigation between tabs works correctly\n4. Test layout on different screen sizes and orientations\n5. Verify accessibility features work correctly\n6. Test that the header displays the correct screen title\n7. Verify profile icon navigation to profile screen\n8. Test notification icon and badge display",
      "priority": "high",
      "dependencies": [
        1
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 6,
      "title": "Implement Network Status Detection and Offline Mode Indicator",
      "description": "Create a service to detect network connectivity status, update the UI accordingly, and manage the application's behavior in offline mode.",
      "details": "1. Implement network status detection using React Native's NetInfo:\n```typescript\nimport NetInfo from '@react-native-community/netinfo';\nimport { createContext, useContext, useEffect, useState } from 'react';\n\ntype NetworkContextType = {\n  isConnected: boolean;\n  lastConnectedAt: Date | null;\n};\n\nconst NetworkContext = createContext<NetworkContextType>({\n  isConnected: true,\n  lastConnectedAt: null,\n});\n\nexport const NetworkProvider: React.FC<{children: React.ReactNode}> = ({ children }) => {\n  const [isConnected, setIsConnected] = useState(true);\n  const [lastConnectedAt, setLastConnectedAt] = useState<Date | null>(null);\n  \n  useEffect(() => {\n    const unsubscribe = NetInfo.addEventListener(state => {\n      const connected = state.isConnected && state.isInternetReachable;\n      setIsConnected(!!connected);\n      \n      if (connected && !isConnected) {\n        setLastConnectedAt(new Date());\n      }\n    });\n    \n    return () => unsubscribe();\n  }, [isConnected]);\n  \n  return (\n    <NetworkContext.Provider value={{ isConnected, lastConnectedAt }}>\n      {children}\n    </NetworkContext.Provider>\n  );\n};\n\nexport const useNetworkStatus = () => useContext(NetworkContext);\n```\n\n2. Create a NetworkStatusIcon component that changes color based on connectivity:\n```typescript\nconst NetworkStatusIcon: React.FC = () => {\n  const { isConnected } = useNetworkStatus();\n  \n  return (\n    <View style={styles.iconContainer}>\n      <Icon \n        name=\"wifi\" \n        color={isConnected ? '#00FF00' : '#FF0000'} \n        size={24} \n      />\n    </View>\n  );\n};\n```\n\n3. Implement a NetworkAwareComponent HOC to conditionally render components based on network status\n4. Create offline mode notification banner that appears when connection is lost\n5. Implement network status persistence in Realm DB to track when the app goes offline/online",
      "testStrategy": "1. Unit test network detection logic\n2. Test NetworkStatusIcon color changes\n3. Simulate network changes to verify detection works correctly\n4. Test offline notification banner appearance and dismissal\n5. Verify network status is correctly persisted in Realm DB\n6. Test NetworkAwareComponent with different network states\n7. Verify integration with the header component\n8. Test behavior when switching between offline and online modes",
      "priority": "high",
      "dependencies": [
        5
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 7,
      "title": "Implement Data Synchronization Service",
      "description": "Create a service to handle synchronization of data between the local Realm database and the external system, including automatic sync every 30 minutes when online.",
      "details": "1. Create a SyncService class to manage data synchronization:\n```typescript\nclass SyncService {\n  private syncInterval: NodeJS.Timeout | null = null;\n  private readonly SYNC_INTERVAL_MS = 30 * 60 * 1000; // 30 minutes\n  \n  constructor(private networkService: NetworkService, private apiClient: ApiClient) {}\n  \n  // Start automatic sync when app is online\n  public startAutoSync(): void {\n    if (this.syncInterval) {\n      clearInterval(this.syncInterval);\n    }\n    \n    this.syncInterval = setInterval(() => {\n      if (this.networkService.isConnected()) {\n        this.syncAll();\n      }\n    }, this.SYNC_INTERVAL_MS);\n    \n    // Also sync immediately if online\n    if (this.networkService.isConnected()) {\n      this.syncAll();\n    }\n  }\n  \n  // Stop automatic sync\n  public stopAutoSync(): void {\n    if (this.syncInterval) {\n      clearInterval(this.syncInterval);\n      this.syncInterval = null;\n    }\n  }\n  \n  // Manually trigger sync\n  public async syncAll(): Promise<SyncResult> {\n    try {\n      // 1. Upload local changes first\n      await this.uploadLocalChanges();\n      \n      // 2. Download updates from server\n      await this.downloadServerUpdates();\n      \n      // 3. Update last sync timestamp\n      await this.updateSyncTimestamp();\n      \n      return { success: true };\n    } catch (error) {\n      console.error('Sync failed:', error);\n      return { success: false, error };\n    }\n  }\n  \n  // Upload changes made locally to the server\n  private async uploadLocalChanges(): Promise<void> {\n    // Get all local changes since last sync from Realm DB\n    // Upload each entity type (tasks, articles, etc.)\n  }\n  \n  // Download updates from server\n  private async downloadServerUpdates(): Promise<void> {\n    // Get updates for each entity type\n    // Update local Realm DB\n  }\n  \n  // Update sync timestamp in local storage\n  private async updateSyncTimestamp(): Promise<void> {\n    // Store current timestamp as last successful sync\n  }\n}\n```\n\n2. Implement entity-specific sync methods for each data model (User, Job/Task, Article, etc.)\n3. Create conflict resolution strategies for each data type\n4. Implement sync queue for failed uploads to retry when connection is restored\n5. Add sync status indicators and progress reporting\n6. Create background sync task using react-native-background-fetch\n7. Implement sync event listeners for UI updates",
      "testStrategy": "1. Unit test SyncService methods\n2. Test automatic sync interval timing\n3. Verify sync works correctly when manually triggered\n4. Test conflict resolution strategies with simulated conflicts\n5. Verify sync queue handles failed uploads correctly\n6. Test sync behavior when switching between offline and online modes\n7. Verify background sync works correctly\n8. Test sync with large datasets\n9. Verify sync status indicators update correctly\n10. Test sync event listeners trigger UI updates",
      "priority": "high",
      "dependencies": [
        2,
        6
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 8,
      "title": "Implement Home Screen (Welcome Dashboard)",
      "description": "Create the primary landing page and active dashboard, allowing users to manage their Shopping List and Daily Tasks based on a selected date.",
      "details": "1. Create HomeScreen component with week selector and tabbed view:\n```typescript\nconst HomeScreen: React.FC = () => {\n  const [selectedDate, setSelectedDate] = useState(new Date());\n  const [activeTab, setActiveTab] = useState('shopping'); // or from user preferences\n  \n  return (\n    <AppLayout title=\"Welcome\">\n      <WeekSelector \n        selectedDate={selectedDate} \n        onDateChange={setSelectedDate} \n      />\n      <TabSelector \n        activeTab={activeTab} \n        onTabChange={setActiveTab} \n        tabs={[{ id: 'shopping', label: 'Shopping List' }, { id: 'tasks', label: 'Tasks' }]} \n      />\n      {activeTab === 'shopping' ? (\n        <HomeShoppingList date={selectedDate} />\n      ) : (\n        <HomeTasks date={selectedDate} />\n      )}\n    </AppLayout>\n  );\n};\n```\n\n2. Implement WeekSelector component with day buttons for the current week\n3. Create TabSelector component for switching between Shopping List and Tasks views\n4. Implement HomeShoppingList component:\n   - Display articles by pickup status\n   - Show interactive elements for navigation\n   - Support expanding/collapsing picked-up items (purple border)\n\n5. Implement HomeTasks component:\n   - List jobs for the selected date\n   - Show visual cues for offline-ready jobs (dashed green border, disconnected network icon)\n   - Add navigation to job details\n\n6. Create automatic content update mechanism when date selection or app settings change\n7. Implement user preference for default tab (shopping or tasks)",
      "testStrategy": "1. Unit test HomeScreen, WeekSelector, TabSelector components\n2. Test date selection and week navigation\n3. Verify tab switching works correctly\n4. Test HomeShoppingList displays correct data for selected date\n5. Test HomeTasks displays correct jobs for selected date\n6. Verify visual indicators for offline-ready jobs\n7. Test expanding/collapsing picked-up items\n8. Verify content updates when date selection changes\n9. Test content updates when app settings change\n10. Verify default tab selection based on user preferences",
      "priority": "medium",
      "dependencies": [
        5,
        7
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 9,
      "title": "Implement User Profile Management",
      "description": "Create the user profile management screens to allow users to view and edit their personal information, manage application settings, and update their account password.",
      "details": "1. Create ProfileScreen with tabbed interface:\n```typescript\nconst ProfileScreen: React.FC = () => {\n  const [activeTab, setActiveTab] = useState('details');\n  \n  return (\n    <AppLayout title=\"Profile\">\n      <TabSelector \n        activeTab={activeTab} \n        onTabChange={setActiveTab} \n        tabs={[{ id: 'details', label: 'Details' }, { id: 'password', label: 'Password' }]} \n      />\n      {activeTab === 'details' ? (\n        <ProfileDetailsTab />\n      ) : (\n        <PasswordChangeTab />\n      )}\n    </AppLayout>\n  );\n};\n```\n\n2. Implement ProfileDetailsTab component:\n   - Display user information (name, contact, gender)\n   - Allow editing editable fields\n   - Show read-only fields (username, roles)\n   - Include app settings (default home tab, photo storage)\n   - Add \"Save Changes\" button\n\n3. Implement PasswordChangeTab component:\n   - Create form for current password, new password, confirm password\n   - Implement password complexity validation\n   - Add \"Change Password\" button\n\n4. Create UserProfileService to handle profile operations:\n```typescript\nclass UserProfileService {\n  // Get user profile from local database\n  async getUserProfile(): Promise<UserProfile> {...}\n  \n  // Update user profile locally and queue for sync\n  async updateUserProfile(updates: Partial<UserProfile>): Promise<boolean> {...}\n  \n  // Update user settings locally\n  async updateUserSettings(settings: UserSettings): Promise<boolean> {...}\n  \n  // Change password (requires online connection)\n  async changePassword(currentPassword: string, newPassword: string): Promise<boolean> {...}\n}\n```\n\n5. Implement success messages for profile updates and password changes\n6. Create logout functionality\n7. Handle offline vs. online behavior for profile operations",
      "testStrategy": "1. Unit test ProfileScreen, ProfileDetailsTab, PasswordChangeTab components\n2. Test form validation for profile editing\n3. Test password complexity validation\n4. Verify read-only fields cannot be edited\n5. Test saving profile changes works correctly\n6. Verify password change functionality works with the authentication service\n7. Test success messages appear correctly\n8. Verify logout functionality works\n9. Test offline behavior for profile operations\n10. Verify user settings are correctly saved and applied",
      "priority": "medium",
      "dependencies": [
        4,
        7
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 10,
      "title": "Implement Shopping List Overview Screen",
      "description": "Create the Shopping List overview screen to display consolidated articles, allow filtering, input picked-up quantities, and mark shopping lists as complete.",
      "details": "1. Create ShoppingListScreen component:\n```typescript\nconst ShoppingListScreen: React.FC = () => {\n  const [selectedDate, setSelectedDate] = useState(new Date());\n  const [warehouse, setWarehouse] = useState<string | null>(null);\n  const [articleType, setArticleType] = useState<string | null>(null);\n  const [articles, setArticles] = useState<Article[]>([]);\n  \n  // Load articles based on filters\n  useEffect(() => {\n    loadArticles(selectedDate, warehouse, articleType);\n  }, [selectedDate, warehouse, articleType]);\n  \n  const handlePickedUpChange = (articleId: string, quantity: number) => {\n    // Update picked up quantity locally\n  };\n  \n  const handleConfirm = () => {\n    // Check if all items are collected\n    const uncollectedItems = articles.filter(a => a.pickedUp < a.reserved);\n    \n    if (uncollectedItems.length > 0) {\n      // Show warning\n    }\n    \n    // Finalize pickup\n  };\n  \n  return (\n    <AppLayout title=\"Shopping List\">\n      <FilterSection \n        date={selectedDate} \n        onDateChange={setSelectedDate}\n        warehouse={warehouse}\n        onWarehouseChange={setWarehouse}\n        articleType={articleType}\n        onArticleTypeChange={setArticleType}\n      />\n      <ArticleList \n        articles={articles} \n        onPickedUpChange={handlePickedUpChange} \n        onArticlePress={navigateToDetail}\n      />\n      <Button title=\"Confirm\" onPress={handleConfirm} />\n    </AppLayout>\n  );\n};\n```\n\n2. Implement FilterSection component with date, warehouse, and article type filters\n3. Create ArticleList component to display articles with input for picked-up quantity\n4. Implement ShoppingListService to handle shopping list operations:\n```typescript\nclass ShoppingListService {\n  // Get articles for shopping list based on filters\n  async getArticles(date: Date, warehouse?: string, type?: string): Promise<Article[]> {...}\n  \n  // Update picked up quantity\n  async updatePickedUpQuantity(articleId: string, quantity: number): Promise<boolean> {...}\n  \n  // Finalize shopping list\n  async confirmShoppingList(date: Date): Promise<boolean> {...}\n}\n```\n\n5. Implement warning dialog for uncollected items\n6. Create success message for shopping list completion\n7. Implement navigation to article detail screen",
      "testStrategy": "1. Unit test ShoppingListScreen, FilterSection, ArticleList components\n2. Test filter functionality for date, warehouse, and article type\n3. Verify picked-up quantity input works correctly\n4. Test warning dialog appears for uncollected items\n5. Verify confirmation process works correctly\n6. Test success message appears after completion\n7. Verify navigation to article detail works\n8. Test offline behavior for shopping list operations\n9. Verify data is correctly saved to local database\n10. Test synchronization of shopping list data",
      "priority": "medium",
      "dependencies": [
        7,
        8
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 11,
      "title": "Implement Shopping List Detail Screen",
      "description": "Create the Shopping List detail screen to allow users to allocate picked-up articles to specific jobs, with auto-distribution and manual adjustment capabilities.",
      "details": "1. Create ShoppingListDetailScreen component:\n```typescript\nconst ShoppingListDetailScreen: React.FC<{ articleId: string }> = ({ articleId }) => {\n  const [article, setArticle] = useState<ArticleDetail | null>(null);\n  const [jobAllocations, setJobAllocations] = useState<JobAllocation[]>([]);\n  const [totalPickedUp, setTotalPickedUp] = useState(0);\n  \n  // Load article details and job allocations\n  useEffect(() => {\n    loadArticleDetail(articleId);\n  }, [articleId]);\n  \n  const handleAutoDistribute = () => {\n    // Implement auto-distribution logic\n  };\n  \n  const handleAllocationChange = (jobId: string, quantity: number) => {\n    // Update allocation for specific job\n    // Validate total matches picked up quantity\n  };\n  \n  const handleSave = () => {\n    // Validate sum of allocations equals total picked up\n    const sum = jobAllocations.reduce((acc, job) => acc + job.quantity, 0);\n    \n    if (sum !== totalPickedUp) {\n      // Show validation error\n      return;\n    }\n    \n    // Save allocations\n  };\n  \n  return (\n    <AppLayout title=\"Article Detail\">\n      <ArticleInfo article={article} />\n      <Button title=\"Auto Distribute\" onPress={handleAutoDistribute} />\n      <JobAllocationList \n        allocations={jobAllocations} \n        onAllocationChange={handleAllocationChange} \n      />\n      <AllocationSummary total={totalPickedUp} allocated={getAllocatedSum()} />\n      <Button title=\"Save\" onPress={handleSave} />\n    </AppLayout>\n  );\n};\n```\n\n2. Implement ArticleInfo component to display article details\n3. Create JobAllocationList component to show jobs needing the article and allow quantity adjustment\n4. Implement AllocationSummary component to show total and allocated quantities\n5. Create auto-distribution algorithm to allocate picked-up quantity across jobs\n6. Implement validation to ensure the sum of allocations matches the picked-up total\n7. Create ShoppingListDetailService to handle article allocation operations:\n```typescript\nclass ShoppingListDetailService {\n  // Get article detail with jobs\n  async getArticleDetail(articleId: string): Promise<ArticleDetail> {...}\n  \n  // Auto-distribute picked up quantity\n  autoDistributeQuantity(article: ArticleDetail): JobAllocation[] {...}\n  \n  // Save job allocations\n  async saveJobAllocations(articleId: string, allocations: JobAllocation[]): Promise<boolean> {...}\n}\n```",
      "testStrategy": "1. Unit test ShoppingListDetailScreen, ArticleInfo, JobAllocationList, AllocationSummary components\n2. Test auto-distribution algorithm with various scenarios\n3. Verify allocation input validation works correctly\n4. Test validation for total allocation matching picked-up quantity\n5. Verify save functionality works correctly\n6. Test error handling for validation failures\n7. Verify data is correctly saved to local database\n8. Test synchronization of allocation data\n9. Test offline behavior for allocation operations\n10. Verify UI updates correctly when allocations change",
      "priority": "medium",
      "dependencies": [
        10
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 12,
      "title": "Implement Task List Screen",
      "description": "Create the Task List screen to display jobs by type (Inspection, Maintenance, Cleaning), with filtering capabilities and visual indicators for job status.",
      "details": "1. Create TaskListScreen component with tabs for job types:\n```typescript\nconst TaskListScreen: React.FC = () => {\n  const [activeTab, setActiveTab] = useState('inspection');\n  const [dateRange, setDateRange] = useState({ start: new Date(), end: new Date() });\n  const [location, setLocation] = useState<string | null>(null);\n  const [subType, setSubType] = useState<string | null>(null);\n  const [showCompleted, setShowCompleted] = useState(false);\n  const [jobs, setJobs] = useState<Job[]>([]);\n  \n  // Load jobs based on filters\n  useEffect(() => {\n    loadJobs(activeTab, dateRange, location, subType, showCompleted);\n  }, [activeTab, dateRange, location, subType, showCompleted]);\n  \n  return (\n    <AppLayout title=\"Tasks\">\n      <TabSelector \n        activeTab={activeTab} \n        onTabChange={setActiveTab} \n        tabs={[\n          { id: 'inspection', label: 'Inspection' },\n          { id: 'maintenance', label: 'Maintenance' },\n          { id: 'cleaning', label: 'Cleaning' }\n        ]} \n      />\n      <FilterSection \n        dateRange={dateRange}\n        onDateRangeChange={setDateRange}\n        location={location}\n        onLocationChange={setLocation}\n        subType={subType}\n        onSubTypeChange={setSubType}\n        showCompleted={showCompleted}\n        onShowCompletedChange={setShowCompleted}\n      />\n      <JobList \n        jobs={jobs} \n        onJobPress={navigateToJobDetail} \n      />\n      {(activeTab === 'maintenance' || activeTab === 'cleaning') && (\n        <FloatingActionButton icon=\"plus\" onPress={navigateToCreateTask} />\n      )}\n    </AppLayout>\n  );\n};\n```\n\n2. Implement TabSelector component for job type tabs\n3. Create FilterSection component with date range, location, sub-type filters, and completed jobs toggle\n4. Implement JobList component with visual indicators:\n   - Completed jobs (green border, checkmark)\n   - Offline-ready jobs (dashed green border, disconnected network icon)\n\n5. Create TaskService to handle job operations:\n```typescript\nclass TaskService {\n  // Get jobs based on filters\n  async getJobs(type: string, filters: JobFilters): Promise<Job[]> {...}\n  \n  // Mark job as offline-ready (cache for offline use)\n  async markJobOfflineReady(jobId: string): Promise<boolean> {...}\n  \n  // Check if job is available offline\n  async isJobOfflineReady(jobId: string): Promise<boolean> {...}\n}\n```\n\n6. Implement FloatingActionButton for creating new Maintenance/Cleaning tasks\n7. Create navigation to job detail and task creation screens",
      "testStrategy": "1. Unit test TaskListScreen, TabSelector, FilterSection, JobList components\n2. Test tab switching between job types\n3. Verify filter functionality for date range, location, and sub-type\n4. Test toggle for showing/hiding completed jobs\n5. Verify visual indicators for completed and offline-ready jobs\n6. Test navigation to job detail works correctly\n7. Verify FloatingActionButton appears only for Maintenance/Cleaning tabs\n8. Test navigation to task creation screen\n9. Verify jobs are loaded correctly based on filters\n10. Test offline behavior for job list operations",
      "priority": "high",
      "dependencies": [
        5,
        7
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 13,
      "title": "Implement Job Detail Screens",
      "description": "Create the Job Detail screens to display general information, location details, and needed articles before starting a job.",
      "details": "1. Create JobDetailScreen component with tabs for different sections:\n```typescript\nconst JobDetailScreen: React.FC<{ jobId: string }> = ({ jobId }) => {\n  const [activeTab, setActiveTab] = useState('general');\n  const [job, setJob] = useState<JobDetail | null>(null);\n  \n  // Load job details\n  useEffect(() => {\n    loadJobDetail(jobId);\n  }, [jobId]);\n  \n  const handleStartJob = () => {\n    // Navigate to Perform Job screen\n  };\n  \n  return (\n    <AppLayout title={`Job: ${job?.title || ''}`}>\n      <TabSelector \n        activeTab={activeTab} \n        onTabChange={setActiveTab} \n        tabs={[\n          { id: 'general', label: 'General' },\n          { id: 'location', label: 'Location' },\n          { id: 'articles', label: 'Needed Articles' }\n        ]} \n      />\n      {activeTab === 'general' && <GeneralInfoTab job={job} />}\n      {activeTab === 'location' && <LocationTab location={job?.location} />}\n      {activeTab === 'articles' && <NeededArticlesTab articles={job?.articles} />}\n      \n      <Button \n        title=\"Start Job\" \n        onPress={handleStartJob} \n        disabled={!job || job.status === 'completed'} \n      />\n    </AppLayout>\n  );\n};\n```\n\n2. Implement GeneralInfoTab component to display job details (title, ID, type, status, dates, estimated hours, instructions)\n3. Create LocationTab component to show location information\n4. Implement NeededArticlesTab component to display articles required for the job\n5. Create JobDetailService to handle job detail operations:\n```typescript\nclass JobDetailService {\n  // Get detailed job information\n  async getJobDetail(jobId: string): Promise<JobDetail> {...}\n  \n  // Check if job can be started\n  async canStartJob(jobId: string): Promise<boolean> {...}\n  \n  // Mark job as started\n  async startJob(jobId: string): Promise<boolean> {...}\n}\n```\n\n6. Implement role-based access control for job actions (e.g., coworkers cannot start jobs)\n7. Handle special case for \"Reviewer rejected job\"\n8. Create navigation to Perform Job screen",
      "testStrategy": "1. Unit test JobDetailScreen, GeneralInfoTab, LocationTab, NeededArticlesTab components\n2. Test tab switching between job detail sections\n3. Verify job details are displayed correctly\n4. Test Start Job button is disabled for completed jobs\n5. Verify role-based access control works correctly\n6. Test special case handling for rejected jobs\n7. Verify navigation to Perform Job screen works\n8. Test offline behavior for job detail operations\n9. Verify data is loaded correctly from local database\n10. Test error handling for missing job data",
      "priority": "high",
      "dependencies": [
        12
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 14,
      "title": "Implement Perform Job Screen",
      "description": "Create the Perform Job screen to guide users through executing a job, including unit/sub-unit selection and inspection point management.",
      "details": "1. Create PerformJobScreen component:\n```typescript\nconst PerformJobScreen: React.FC<{ jobId: string }> = ({ jobId }) => {\n  const [job, setJob] = useState<JobDetail | null>(null);\n  const [selectedUnit, setSelectedUnit] = useState<string | null>(null);\n  const [points, setPoints] = useState<InspectionPoint[]>([]);\n  const [progress, setProgress] = useState(0);\n  \n  // Load job details and points\n  useEffect(() => {\n    loadJobAndPoints(jobId);\n  }, [jobId]);\n  \n  // Update points when unit changes\n  useEffect(() => {\n    if (selectedUnit) {\n      loadPointsForUnit(jobId, selectedUnit);\n    }\n  }, [selectedUnit]);\n  \n  // Calculate progress\n  useEffect(() => {\n    if (job) {\n      const completedPoints = job.totalCompletedPoints || 0;\n      const totalPoints = job.totalPoints || 1;\n      setProgress(completedPoints / totalPoints);\n    }\n  }, [job]);\n  \n  const handleUnitChange = (unitId: string) => {\n    setSelectedUnit(unitId);\n  };\n  \n  const handlePointUpdate = (pointId: string, updates: Partial<InspectionPoint>) => {\n    // Update point locally\n  };\n  \n  const handleSave = async () => {\n    // Save progress locally\n  };\n  \n  const handleComplete = () => {\n    // Navigate to job summary\n  };\n  \n  return (\n    <AppLayout title=\"Perform Job\">\n      <ProgressBar value={progress} />\n      <UnitSelector \n        units={job?.units || []} \n        selectedUnit={selectedUnit} \n        onUnitChange={handleUnitChange} \n      />\n      <InspectionPointList \n        points={points} \n        onPointUpdate={handlePointUpdate} \n      />\n      <ButtonRow>\n        <Button title=\"Save\" onPress={handleSave} />\n        <Button title=\"Complete\" onPress={handleComplete} />\n      </ButtonRow>\n    </AppLayout>\n  );\n};\n```\n\n2. Implement ProgressBar component to show completion progress\n3. Create UnitSelector component with visual indicators for completed units (green checkmarks)\n4. Implement InspectionPointList component to display and manage points\n5. Create InspectionPointItem component with:\n   - Status selection (Green/Orange/Red)\n   - Description input\n   - Photo capture/management (up to 8 photos)\n   - Cost input\n   - Follow-up action creation\n\n6. Implement PerformJobService to handle job execution:\n```typescript\nclass PerformJobService {\n  // Get job details with units and points\n  async getJobWithPoints(jobId: string): Promise<JobDetail> {...}\n  \n  // Get points for specific unit\n  async getPointsForUnit(jobId: string, unitId: string): Promise<InspectionPoint[]> {...}\n  \n  // Update inspection point\n  async updateInspectionPoint(jobId: string, pointId: string, updates: Partial<InspectionPoint>): Promise<boolean> {...}\n  \n  // Save job progress\n  async saveJobProgress(jobId: string): Promise<boolean> {...}\n  \n  // Check if job can be completed\n  async canCompleteJob(jobId: string): Promise<{canComplete: boolean, reason?: string}> {...}\n}\n```\n\n7. Implement photo capture and management functionality\n8. Create cost input component with validation\n9. Implement follow-up action creation UI",
      "testStrategy": "1. Unit test PerformJobScreen, ProgressBar, UnitSelector, InspectionPointList, InspectionPointItem components\n2. Test unit selection and point loading\n3. Verify progress calculation and display\n4. Test point status updates (Green/Orange/Red)\n5. Verify description input works correctly\n6. Test photo capture, display, and deletion\n7. Verify cost input and validation\n8. Test follow-up action creation\n9. Verify save functionality works correctly\n10. Test navigation to job summary\n11. Verify offline behavior for job execution\n12. Test role-based access control (e.g., coworker restrictions)",
      "priority": "high",
      "dependencies": [
        13
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 15,
      "title": "Implement Article Management Screens",
      "description": "Create screens for managing used, returned, and broken articles during job execution, with source distinction (job, location, van) and specific validation rules.",
      "details": "1. Create base ArticleManagementScreen component:\n```typescript\nconst ArticleManagementScreen: React.FC<{\n  jobId: string;\n  type: 'used' | 'returned' | 'broken';\n}> = ({ jobId, type }) => {\n  const [articles, setArticles] = useState<ArticleWithSource[]>([]);\n  const [isOnline] = useNetworkStatus();\n  \n  // Load articles based on type\n  useEffect(() => {\n    loadArticles(jobId, type);\n  }, [jobId, type]);\n  \n  const handleQuantityChange = (articleId: string, source: 'job' | 'location' | 'van', quantity: number) => {\n    // Update article quantity\n  };\n  \n  const handleAddArticle = (source: 'job' | 'location' | 'van') => {\n    // Show article selection modal\n  };\n  \n  const handleSave = async () => {\n    // Check if any \"additional\" articles from Van and online requirement\n    const hasAdditionalVanArticles = articles.some(a => a.source === 'van' && a.isAdditional);\n    \n    if (hasAdditionalVanArticles && !isOnline) {\n      // Show error - cannot save additional van articles offline\n      return;\n    }\n    \n    // Save articles\n  };\n  \n  return (\n    <AppLayout title={`${type.charAt(0).toUpperCase() + type.slice(1)} Articles`}>\n      <SourceTabs onAddArticle={handleAddArticle} />\n      <ArticleList \n        articles={articles} \n        onQuantityChange={handleQuantityChange} \n      />\n      <Button title=\"Save\" onPress={handleSave} />\n    </AppLayout>\n  );\n};\n```\n\n2. Create specific screens for each article type:\n   - UsedArticlesScreen\n   - ReturnedArticlesScreen\n   - BrokenArticlesScreen\n\n3. Implement SourceTabs component to switch between article sources (Job, Location, Van)\n4. Create ArticleList component to display and manage articles\n5. Implement ArticleSelectionModal for adding articles\n6. Create ArticleManagementService to handle article operations:\n```typescript\nclass ArticleManagementService {\n  // Get articles by type and job\n  async getArticles(jobId: string, type: 'used' | 'returned' | 'broken'): Promise<ArticleWithSource[]> {...}\n  \n  // Get available articles for selection\n  async getAvailableArticles(jobId: string, source: 'job' | 'location' | 'van'): Promise<Article[]> {...}\n  \n  // Update article quantity\n  async updateArticleQuantity(jobId: string, articleId: string, source: 'job' | 'location' | 'van', type: 'used' | 'returned' | 'broken', quantity: number): Promise<boolean> {...}\n  \n  // Save article changes\n  async saveArticleChanges(jobId: string, type: 'used' | 'returned' | 'broken'): Promise<boolean> {...}\n  \n  // Check if changes can be saved offline\n  canSaveOffline(articles: ArticleWithSource[]): boolean {...}\n}\n```\n\n7. Implement validation rules for each article type and source\n8. Create error handling for offline restrictions with \"additional\" articles",
      "testStrategy": "1. Unit test ArticleManagementScreen, SourceTabs, ArticleList components\n2. Test specific screens for each article type\n3. Verify article quantity updates work correctly\n4. Test article selection and addition\n5. Verify validation rules for each article type and source\n6. Test offline restrictions for \"additional\" articles\n7. Verify save functionality works correctly\n8. Test error handling for validation failures\n9. Verify data is correctly saved to local database\n10. Test synchronization of article data",
      "priority": "medium",
      "dependencies": [
        14
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 16,
      "title": "Implement Job Summary Screen",
      "description": "Create the Job Summary screen with expandable sections for results, time spent, articles, expenditures, follow-up actions, and general feedback before job submission.",
      "details": "1. Create JobSummaryScreen component:\n```typescript\nconst JobSummaryScreen: React.FC<{ jobId: string }> = ({ jobId }) => {\n  const [jobSummary, setJobSummary] = useState<JobSummary | null>(null);\n  const [expandedSections, setExpandedSections] = useState<string[]>(['results']);\n  \n  // Load job summary\n  useEffect(() => {\n    loadJobSummary(jobId);\n  }, [jobId]);\n  \n  const toggleSection = (section: string) => {\n    if (expandedSections.includes(section)) {\n      setExpandedSections(expandedSections.filter(s => s !== section));\n    } else {\n      setExpandedSections([...expandedSections, section]);\n    }\n  };\n  \n  const handleSubmit = async () => {\n    // Submit job\n  };\n  \n  return (\n    <AppLayout title=\"Job Summary\">\n      <ScrollView>\n        <ExpandableSection \n          title=\"Results\" \n          expanded={expandedSections.includes('results')} \n          onToggle={() => toggleSection('results')} \n        >\n          <ResultsSection results={jobSummary?.results} />\n        </ExpandableSection>\n        \n        <ExpandableSection \n          title=\"Time Spent\" \n          expanded={expandedSections.includes('time')} \n          onToggle={() => toggleSection('time')} \n        >\n          <TimeSection time={jobSummary?.time} />\n        </ExpandableSection>\n        \n        {/* Similar sections for Articles, Expenditures, Follow-up Actions, Feedback */}\n      </ScrollView>\n      \n      <Button title=\"Submit Job\" onPress={handleSubmit} />\n    </AppLayout>\n  );\n};\n```\n\n2. Implement ExpandableSection component for collapsible sections\n3. Create section-specific components:\n   - ResultsSection\n   - TimeSection\n   - ArticlesSection (with sub-sections for Used, Returned, Broken)\n   - ExpendituresSection\n   - FollowUpActionsSection\n   - FeedbackSection\n\n4. Implement JobSummaryService to handle summary operations:\n```typescript\nclass JobSummaryService {\n  // Get job summary\n  async getJobSummary(jobId: string): Promise<JobSummary> {...}\n  \n  // Submit completed job\n  async submitJob(jobId: string): Promise<boolean> {...}\n  \n  // Check if job can be submitted\n  async canSubmitJob(jobId: string): Promise<{canSubmit: boolean, reason?: string}> {...}\n}\n```\n\n5. Create validation for job submission\n6. Implement success message for job submission\n7. Handle role-based restrictions (e.g., coworkers can only edit \"Actual hours\")",
      "testStrategy": "1. Unit test JobSummaryScreen, ExpandableSection, and section-specific components\n2. Test section expansion/collapse functionality\n3. Verify job summary data is displayed correctly\n4. Test job submission validation\n5. Verify success message appears after submission\n6. Test role-based restrictions\n7. Verify data is correctly loaded from local database\n8. Test offline behavior for job summary\n9. Verify synchronization of submitted job data\n10. Test error handling for submission failures",
      "priority": "medium",
      "dependencies": [
        14,
        15
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 17,
      "title": "Implement Task Creation Workflow",
      "description": "Create the two-step workflow for creating new Maintenance and Cleaning tasks, including general job information and template application for job points.",
      "details": "1. Create CreateTaskScreen component with step indicator:\n```typescript\nconst CreateTaskScreen: React.FC<{ type: 'maintenance' | 'cleaning' }> = ({ type }) => {\n  const [step, setStep] = useState(1);\n  const [taskData, setTaskData] = useState<NewTaskData>({ type });\n  \n  const handleStep1Complete = (data: Step1Data) => {\n    setTaskData({ ...taskData, ...data });\n    setStep(2);\n  };\n  \n  const handleStep2Complete = (data: Step2Data) => {\n    setTaskData({ ...taskData, ...data });\n    createTask(taskData);\n  };\n  \n  const handleBack = () => {\n    if (step === 2) {\n      setStep(1);\n    } else {\n      // Navigate back to task list\n    }\n  };\n  \n  return (\n    <AppLayout title={`Create ${type.charAt(0).toUpperCase() + type.slice(1)} Task`}>\n      <StepIndicator currentStep={step} totalSteps={2} />\n      \n      {step === 1 ? (\n        <CreateTaskStep1 \n          initialData={taskData} \n          onComplete={handleStep1Complete} \n        />\n      ) : (\n        <CreateTaskStep2 \n          taskData={taskData} \n          onComplete={handleStep2Complete} \n        />\n      )}\n      \n      <Button title=\"Back\" onPress={handleBack} />\n    </AppLayout>\n  );\n};\n```\n\n2. Implement CreateTaskStep1 component for general job information:\n   - Location selection\n   - Unit selection\n   - Date selection\n   - Estimated hours input\n\n3. Create CreateTaskStep2 component for template application:\n   - Template selection\n   - Point configuration\n   - Unit modification handling\n\n4. Implement TaskCreationService to handle task creation:\n```typescript\nclass TaskCreationService {\n  // Get available locations\n  async getLocations(): Promise<Location[]> {...}\n  \n  // Get units for location\n  async getUnits(locationId: string): Promise<Unit[]> {...}\n  \n  // Get available templates\n  async getTemplates(type: 'maintenance' | 'cleaning'): Promise<Template[]> {...}\n  \n  // Apply template to task\n  async applyTemplate(taskData: NewTaskData, templateId: string): Promise<TaskWithPoints> {...}\n  \n  // Create new task\n  async createTask(taskData: NewTaskData): Promise<{success: boolean, taskId?: string}> {...}\n}\n```\n\n5. Implement template application logic with handling for \"rainy case\" scenarios\n6. Create unit modification handling with warnings\n7. Implement validation for task creation (e.g., tasks without points)\n8. Create success message for task creation",
      "testStrategy": "1. Unit test CreateTaskScreen, CreateTaskStep1, CreateTaskStep2 components\n2. Test step navigation (forward and back)\n3. Verify location and unit selection works correctly\n4. Test date selection and estimated hours input\n5. Verify template selection and application\n6. Test point configuration and management\n7. Verify unit modification handling and warnings\n8. Test validation for task creation\n9. Verify success message appears after creation\n10. Test offline behavior for task creation\n11. Verify data is correctly saved to local database\n12. Test synchronization of created task data",
      "priority": "medium",
      "dependencies": [
        12
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 18,
      "title": "Implement Photo Capture and Management",
      "description": "Create a reusable photo capture and management component for inspection points, supporting up to 8 photos per point with view/delete capabilities.",
      "details": "1. Create PhotoManager component:\n```typescript\nconst PhotoManager: React.FC<{\n  photos: Photo[];\n  onAddPhoto: () => void;\n  onDeletePhoto: (photoId: string) => void;\n  onViewPhoto: (photoId: string) => void;\n  maxPhotos?: number;\n}> = ({ photos, onAddPhoto, onDeletePhoto, onViewPhoto, maxPhotos = 8 }) => {\n  return (\n    <View style={styles.container}>\n      <Text style={styles.title}>Photos ({photos.length}/{maxPhotos})</Text>\n      <View style={styles.photoGrid}>\n        {photos.map(photo => (\n          <PhotoThumbnail \n            key={photo.id} \n            photo={photo} \n            onDelete={() => onDeletePhoto(photo.id)} \n            onView={() => onViewPhoto(photo.id)} \n          />\n        ))}\n        {photos.length < maxPhotos && (\n          <AddPhotoButton onPress={onAddPhoto} />\n        )}\n      </View>\n    </View>\n  );\n};\n```\n\n2. Implement PhotoThumbnail component to display photo with delete button\n3. Create AddPhotoButton component\n4. Implement PhotoCaptureScreen for taking new photos\n5. Create PhotoViewScreen for viewing full-size photos\n6. Implement PhotoService to handle photo operations:\n```typescript\nclass PhotoService {\n  // Take new photo\n  async capturePhoto(): Promise<Photo> {...}\n  \n  // Get photo from gallery\n  async selectPhotoFromGallery(): Promise<Photo> {...}\n  \n  // Save photo to local storage\n  async savePhoto(photo: Photo): Promise<string> {...}\n  \n  // Delete photo from local storage\n  async deletePhoto(photoId: string): Promise<boolean> {...}\n  \n  // Get photo storage path based on user settings\n  getPhotoStoragePath(): string {...}\n}\n```\n\n7. Implement photo compression to reduce storage usage\n8. Create photo storage strategy based on user settings\n9. Implement photo synchronization with external system",
      "testStrategy": "1. Unit test PhotoManager, PhotoThumbnail, AddPhotoButton components\n2. Test photo capture functionality\n3. Verify photo gallery selection works\n4. Test photo deletion\n5. Verify maximum photo limit is enforced\n6. Test photo viewing functionality\n7. Verify photo compression works correctly\n8. Test photo storage based on user settings\n9. Verify photo synchronization works\n10. Test offline behavior for photo operations\n11. Verify photos are correctly saved to local storage\n12. Test error handling for photo operations",
      "priority": "medium",
      "dependencies": [
        14
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 19,
      "title": "Implement Role-Based Access Control",
      "description": "Implement role-based functionality and UI adaptation based on the user's role (e.g., 'coworker') or job status (e.g., 'Reviewer rejected job').",
      "details": "1. Create RoleBasedAccessControl service:\n```typescript\nclass RoleBasedAccessControl {\n  // Check if user has permission for specific action\n  async hasPermission(userId: string, action: string, resourceType: string, resourceId?: string): Promise<boolean> {...}\n  \n  // Get user roles\n  async getUserRoles(userId: string): Promise<string[]> {...}\n  \n  // Check if user is a coworker\n  async isCoworker(userId: string): Promise<boolean> {...}\n  \n  // Check if job was rejected by reviewer\n  async isRejectedByReviewer(jobId: string): Promise<boolean> {...}\n}\n```\n\n2. Implement RoleAwareComponent HOC to conditionally render components based on permissions:\n```typescript\nconst RoleAwareComponent: React.FC<{\n  requiredPermission: string;\n  resourceType: string;\n  resourceId?: string;\n  fallback?: React.ReactNode;\n  children: React.ReactNode;\n}> = ({ requiredPermission, resourceType, resourceId, fallback, children }) => {\n  const [hasPermission, setHasPermission] = useState(false);\n  const { userId } = useAuth();\n  \n  useEffect(() => {\n    const checkPermission = async () => {\n      const rbac = new RoleBasedAccessControl();\n      const permitted = await rbac.hasPermission(userId, requiredPermission, resourceType, resourceId);\n      setHasPermission(permitted);\n    };\n    \n    checkPermission();\n  }, [userId, requiredPermission, resourceType, resourceId]);\n  \n  return hasPermission ? <>{children}</> : <>{fallback || null}</>;\n};\n```\n\n3. Implement special case handling for \"Reviewer rejected job\":\n   - Allow viewing and restarting rejected jobs\n   - Restrict editing articles \"from job\"\n\n4. Create coworker role restrictions:\n   - View-only access to \"Perform Job\" and \"Summary\" pages\n   - Allow editing \"Actual hours\"\n\n5. Update affected screens to use RoleAwareComponent for conditional rendering\n6. Implement permission checks in service methods\n7. Create role-based navigation restrictions",
      "testStrategy": "1. Unit test RoleBasedAccessControl service and RoleAwareComponent\n2. Test permission checks for different user roles\n3. Verify coworker restrictions work correctly\n4. Test special case handling for rejected jobs\n5. Verify conditional rendering based on permissions\n6. Test role-based navigation restrictions\n7. Verify service method permission checks\n8. Test with different user roles and job statuses\n9. Verify UI adapts correctly based on role and job status\n10. Test error handling for permission checks",
      "priority": "medium",
      "dependencies": [
        4,
        13,
        14,
        16
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 20,
      "title": "Implement Comprehensive Testing and Quality Assurance",
      "description": "Create a comprehensive testing suite for the HomEE mobile application, including unit tests, integration tests, and end-to-end tests to ensure functionality, performance, and reliability.",
      "details": "1. Set up testing framework:\n```bash\nnpm install --save-dev jest @testing-library/react-native @testing-library/jest-native jest-fetch-mock\n```\n\n2. Configure Jest for React Native:\n```javascript\n// jest.config.js\nmodule.exports = {\n  preset: 'react-native',\n  moduleFileExtensions: ['ts', 'tsx', 'js', 'jsx', 'json', 'node'],\n  transformIgnorePatterns: [\n    'node_modules/(?!(react-native|@react-native|react-navigation|@react-navigation)/)',\n  ],\n  setupFilesAfterEnv: ['@testing-library/jest-native/extend-expect'],\n  testPathIgnorePatterns: ['/node_modules/', '/android/', '/ios/'],\n};\n```\n\n3. Create unit tests for all components:\n```typescript\n// Example component test\nimport React from 'react';\nimport { render, fireEvent } from '@testing-library/react-native';\nimport { NetworkStatusIcon } from '../components/NetworkStatusIcon';\nimport { NetworkProvider } from '../contexts/NetworkContext';\n\ntest('NetworkStatusIcon changes color based on connectivity', () => {\n  const { getByTestId, rerender } = render(\n    <NetworkProvider initialState={{ isConnected: true }}>\n      <NetworkStatusIcon />\n    </NetworkProvider>\n  );\n  \n  const icon = getByTestId('network-status-icon');\n  expect(icon.props.style.color).toBe('#00FF00'); // Green for online\n  \n  // Rerender with offline state\n  rerender(\n    <NetworkProvider initialState={{ isConnected: false }}>\n      <NetworkStatusIcon />\n    </NetworkProvider>\n  );\n  \n  expect(icon.props.style.color).toBe('#FF0000'); // Red for offline\n});\n```\n\n4. Create unit tests for all services\n5. Implement integration tests for key workflows:\n   - Authentication flow\n   - Task management flow\n   - Shopping list flow\n   - Job execution flow\n\n6. Set up end-to-end testing with Detox:\n```bash\nnpm install --save-dev detox\ndetox init\n```\n\n7. Create end-to-end test scenarios:\n```javascript\ndescribe('Authentication Flow', () => {\n  beforeAll(async () => {\n    await device.launchApp();\n  });\n  \n  beforeEach(async () => {\n    await device.reloadReactNative();\n  });\n  \n  it('should login successfully with valid credentials', async () => {\n    await element(by.id('username-input')).typeText('testuser');\n    await element(by.id('continue-button')).tap();\n    await element(by.id('password-input')).typeText('password123');\n    await element(by.id('login-button')).tap();\n    \n    await expect(element(by.text('Welcome'))).toBeVisible();\n  });\n});\n```\n\n8. Implement performance testing:\n   - Measure and optimize app startup time\n   - Test performance with large datasets\n   - Optimize rendering performance\n\n9. Create accessibility tests\n10. Implement security testing:\n    - Test authentication security\n    - Verify secure storage of sensitive data\n    - Test offline data protection",
      "testStrategy": "1. Run unit tests for all components and services\n2. Execute integration tests for key workflows\n3. Perform end-to-end testing with Detox\n4. Conduct performance testing under various conditions\n5. Test accessibility features\n6. Perform security testing\n7. Test offline functionality\n8. Verify synchronization works correctly\n9. Test on multiple device types and OS versions\n10. Conduct user acceptance testing with real users",
      "priority": "medium",
      "dependencies": [
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19
      ],
      "status": "pending",
      "subtasks": []
    }
  ]
}